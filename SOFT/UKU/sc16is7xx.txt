; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\EXE\sc16is7xx.o --asm_dir=.\ --list_dir=.\ --depend=.\EXE\sc16is7xx.d --cpu=Cortex-M3 --apcs=interwork -O3 -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\NXP\LPC17xx -D__MICROLIB -DUKU2071x -DEXT_BOARD_V_2 -DWG12232A --omf_browse=.\EXE\sc16is7xx.crf sc16is7xx.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sc16is700_spi_init PROC
;;;18     //настройка SPI1
;;;19     void sc16is700_spi_init(void)
000000  48b8              LDR      r0,|L1.740|
;;;20     {
;;;21     SET_REG( LPC_PINCON->PINSEL0, 0, 0*2, 2);
000002  6801              LDR      r1,[r0,#0]
000004  f0210103          BIC      r1,r1,#3
000008  6001              STR      r1,[r0,#0]
;;;22     SET_REG( LPC_PINCON->PINSEL0, 3, 15*2, 2);
00000a  6801              LDR      r1,[r0,#0]
00000c  f0414140          ORR      r1,r1,#0xc0000000
000010  6001              STR      r1,[r0,#0]
;;;23     SET_REG( LPC_PINCON->PINSEL1, 0, (16-16)*2, 2);
000012  6841              LDR      r1,[r0,#4]
000014  f0210103          BIC      r1,r1,#3
000018  6041              STR      r1,[r0,#4]
;;;24     SET_REG( LPC_PINCON->PINSEL1, 3, (17-16)*2, 2);
00001a  6841              LDR      r1,[r0,#4]
00001c  f041010c          ORR      r1,r1,#0xc
000020  6041              STR      r1,[r0,#4]
;;;25     SET_REG( LPC_PINCON->PINSEL1, 3, (18-16)*2, 2); 
000022  6841              LDR      r1,[r0,#4]
000024  f0410130          ORR      r1,r1,#0x30
000028  6041              STR      r1,[r0,#4]
;;;26     /*
;;;27     S1SPCCR=100;
;;;28     S1SPCR=0x3f; */
;;;29     
;;;30     LPC_SPI->SPCCR=20;
00002a  48af              LDR      r0,|L1.744|
00002c  2114              MOVS     r1,#0x14
00002e  60c1              STR      r1,[r0,#0xc]
;;;31     LPC_SPI->SPCR=0x20;
000030  2120              MOVS     r1,#0x20
000032  6001              STR      r1,[r0,#0]
;;;32     }
000034  4770              BX       lr
;;;33     
                          ENDP

                  sc16is700_wr_buff PROC
;;;35     //Отправка num байт из программного буфера передачи в sc16is700
;;;36     void sc16is700_wr_buff(char reg_num,char num)
000036  e92d41f0          PUSH     {r4-r8,lr}
;;;37     {
00003a  4602              MOV      r2,r0
00003c  460e              MOV      r6,r1
;;;38     short i;
;;;39     sc16is700_spi_init();
00003e  f7fffffe          BL       sc16is700_spi_init
;;;40     delay_us(2);
000042  2118              MOVS     r1,#0x18
                  |L1.68|
000044  1e49              SUBS     r1,r1,#1
000046  d1fd              BNE      |L1.68|
;;;41     sc16is700_CS_ON 
000048  4da8              LDR      r5,|L1.748|
00004a  6828              LDR      r0,[r5,#0]
00004c  f0400001          ORR      r0,r0,#1
000050  6028              STR      r0,[r5,#0]
000052  69e8              LDR      r0,[r5,#0x1c]
000054  f0400001          ORR      r0,r0,#1
000058  61e8              STR      r0,[r5,#0x1c]
;;;42     spi1((reg_num&0x0f)<<3);
00005a  0710              LSLS     r0,r2,#28
00005c  0e40              LSRS     r0,r0,#25
00005e  f7fffffe          BL       spi1
;;;43     for (i=0;i<num;i++)spi1(tx_buffer_sc16is700[i]);
000062  2400              MOVS     r4,#0
000064  4fa2              LDR      r7,|L1.752|
000066  e004              B        |L1.114|
                  |L1.104|
000068  5d38              LDRB     r0,[r7,r4]
00006a  f7fffffe          BL       spi1
00006e  1c64              ADDS     r4,r4,#1
000070  b224              SXTH     r4,r4
                  |L1.114|
000072  42b4              CMP      r4,r6
000074  dbf8              BLT      |L1.104|
;;;44     sc16is700_CS_OFF
000076  6828              LDR      r0,[r5,#0]
000078  f0400001          ORR      r0,r0,#1
00007c  6028              STR      r0,[r5,#0]
00007e  69a8              LDR      r0,[r5,#0x18]
000080  f0400001          ORR      r0,r0,#1
000084  61a8              STR      r0,[r5,#0x18]
;;;45     }
000086  e8bd81f0          POP      {r4-r8,pc}
;;;46     
                          ENDP

                  sc16is700_wr_byte PROC
;;;47     void sc16is700_wr_byte(char reg_num,char data)
00008a  b570              PUSH     {r4-r6,lr}
;;;48     {
00008c  4602              MOV      r2,r0
00008e  460d              MOV      r5,r1
;;;49     sc16is700_spi_init();
000090  f7fffffe          BL       sc16is700_spi_init
;;;50     delay_us(2);
000094  2018              MOVS     r0,#0x18
                  |L1.150|
000096  1e40              SUBS     r0,r0,#1
000098  d1fd              BNE      |L1.150|
;;;51     sc16is700_CS_ON
00009a  4c94              LDR      r4,|L1.748|
00009c  6820              LDR      r0,[r4,#0]
00009e  f0400001          ORR      r0,r0,#1
0000a2  6020              STR      r0,[r4,#0]
0000a4  69e0              LDR      r0,[r4,#0x1c]
0000a6  f0400001          ORR      r0,r0,#1
0000aa  61e0              STR      r0,[r4,#0x1c]
;;;52     spi1((reg_num&0x0f)<<3);
0000ac  0710              LSLS     r0,r2,#28
0000ae  0e40              LSRS     r0,r0,#25
0000b0  f7fffffe          BL       spi1
;;;53     spi1(data);
0000b4  4628              MOV      r0,r5
0000b6  f7fffffe          BL       spi1
;;;54     sc16is700_CS_OFF
0000ba  6820              LDR      r0,[r4,#0]
0000bc  f0400001          ORR      r0,r0,#1
0000c0  6020              STR      r0,[r4,#0]
0000c2  69a0              LDR      r0,[r4,#0x18]
0000c4  f0400001          ORR      r0,r0,#1
0000c8  61a0              STR      r0,[r4,#0x18]
;;;55     }
0000ca  bd70              POP      {r4-r6,pc}
;;;56     
                          ENDP

                  sc16is700_rd_byte PROC
;;;57     
;;;58     char sc16is700_rd_byte(char reg_num)
0000cc  b510              PUSH     {r4,lr}
;;;59     {
0000ce  4602              MOV      r2,r0
;;;60     char out;
;;;61     sc16is700_spi_init();
0000d0  f7fffffe          BL       sc16is700_spi_init
;;;62     delay_us(2);
0000d4  2118              MOVS     r1,#0x18
                  |L1.214|
0000d6  1e49              SUBS     r1,r1,#1
0000d8  d1fd              BNE      |L1.214|
;;;63     sc16is700_CS_ON
0000da  4c84              LDR      r4,|L1.748|
0000dc  6820              LDR      r0,[r4,#0]
0000de  f0400001          ORR      r0,r0,#1
0000e2  6020              STR      r0,[r4,#0]
0000e4  69e0              LDR      r0,[r4,#0x1c]
0000e6  f0400001          ORR      r0,r0,#1
0000ea  61e0              STR      r0,[r4,#0x1c]
;;;64     spi1(((reg_num&0x0f)<<3)|0x80);
0000ec  f002000f          AND      r0,r2,#0xf
0000f0  2180              MOVS     r1,#0x80
0000f2  ea4100c0          ORR      r0,r1,r0,LSL #3
0000f6  f7fffffe          BL       spi1
;;;65     out = spi1(0xff);
0000fa  20ff              MOVS     r0,#0xff
0000fc  f7fffffe          BL       spi1
;;;66     sc16is700_CS_OFF
000100  6821              LDR      r1,[r4,#0]
000102  f0410101          ORR      r1,r1,#1
000106  6021              STR      r1,[r4,#0]
000108  69a1              LDR      r1,[r4,#0x18]
00010a  f0410101          ORR      r1,r1,#1
00010e  61a1              STR      r1,[r4,#0x18]
;;;67     return out;
;;;68     }
000110  bd10              POP      {r4,pc}
;;;69     
                          ENDP

                  sc16is700_init_ PROC
;;;70     void sc16is700_init_(void)
000112  b510              PUSH     {r4,lr}
;;;71     {
;;;72     sc16is700_wr_byte(CS16IS7xx_LCR, 0x80);
000114  2180              MOVS     r1,#0x80
000116  2003              MOVS     r0,#3
000118  f7fffffe          BL       sc16is700_wr_byte
;;;73     sc16is700_wr_byte(CS16IS7xx_DLL, 0x41);
00011c  2141              MOVS     r1,#0x41
00011e  2000              MOVS     r0,#0
000120  f7fffffe          BL       sc16is700_wr_byte
;;;74     sc16is700_wr_byte(CS16IS7xx_DLH, 0x00);
000124  2100              MOVS     r1,#0
000126  2001              MOVS     r0,#1
000128  f7fffffe          BL       sc16is700_wr_byte
;;;75     sc16is700_wr_byte(CS16IS7xx_LCR, 0xBF);
00012c  21bf              MOVS     r1,#0xbf
00012e  2003              MOVS     r0,#3
000130  f7fffffe          BL       sc16is700_wr_byte
;;;76     sc16is700_wr_byte(CS16IS7xx_EFR, 0X10);
000134  2110              MOVS     r1,#0x10
000136  2002              MOVS     r0,#2
000138  f7fffffe          BL       sc16is700_wr_byte
;;;77     sc16is700_wr_byte(CS16IS7xx_LCR, 0x03);
00013c  2103              MOVS     r1,#3
00013e  4608              MOV      r0,r1
000140  f7fffffe          BL       sc16is700_wr_byte
;;;78     sc16is700_wr_byte(CS16IS7xx_FCR, 0x06);
000144  2106              MOVS     r1,#6
000146  2002              MOVS     r0,#2
000148  f7fffffe          BL       sc16is700_wr_byte
;;;79     sc16is700_wr_byte(CS16IS7xx_FCR, 0x01);
00014c  2101              MOVS     r1,#1
00014e  2002              MOVS     r0,#2
000150  f7fffffe          BL       sc16is700_wr_byte
;;;80     sc16is700_wr_byte(CS16IS7xx_EFCR, 0X30);
000154  2130              MOVS     r1,#0x30
000156  e8bd4010          POP      {r4,lr}
00015a  200f              MOVS     r0,#0xf
00015c  e7fe              B        sc16is700_wr_byte
;;;81     //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;82     //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;83     //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;84     //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;85     //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;86     }
;;;87     
                          ENDP

                  sc16is700_init PROC
;;;89     
;;;90     void sc16is700_init(uint32_t baudrate)
00015e  4965              LDR      r1,|L1.756|
;;;91     {
000160  b570              PUSH     {r4-r6,lr}
;;;92     
;;;93     unsigned char baud_h,baud_l;
;;;94     
;;;95     baud_h = (char)((10000000U/16U/baudrate)>>8);
000162  fbb1f1f0          UDIV     r1,r1,r0
000166  f3c12407          UBFX     r4,r1,#8,#8
;;;96     baud_l = (char)((10000000U/16U/baudrate)); 
;;;97     
;;;98     if(baudrate==57600U)baud_l=11;
;;;99     //if(baudrate==115200U)baud_l=6;
;;;100    
;;;101    
;;;102    baud_h = (char)((10000000U/16U/baudrate)>>8);
;;;103    baud_l = (char)((10000000U/16U/baudrate));
00016a  b2cd              UXTB     r5,r1
;;;104    
;;;105    if(RS485_QWARZ_DIGIT==40)
00016c  4962              LDR      r1,|L1.760|
00016e  f9b11000          LDRSH    r1,[r1,#0]  ; RS485_QWARZ_DIGIT
000172  2928              CMP      r1,#0x28
000174  d002              BEQ      |L1.380|
;;;106    	{
;;;107    	baud_h = (char)((40000000U/16U/baudrate)>>8);
;;;108    	baud_l = (char)((40000000U/16U/baudrate));
;;;109    	} 
;;;110    if(RS485_QWARZ_DIGIT==30)
000176  291e              CMP      r1,#0x1e
000178  d002              BEQ      |L1.384|
00017a  e007              B        |L1.396|
                  |L1.380|
00017c  495f              LDR      r1,|L1.764|
00017e  e000              B        |L1.386|
                  |L1.384|
;;;111    	{
;;;112    	baud_h = (char)((30000000U/16U/baudrate)>>8);
000180  495f              LDR      r1,|L1.768|
                  |L1.386|
000182  fbb1f0f0          UDIV     r0,r1,r0              ;107
000186  f3c02407          UBFX     r4,r0,#8,#8           ;107
00018a  b2c5              UXTB     r5,r0                 ;108
                  |L1.396|
;;;113    	baud_l = (char)((30000000U/16U/baudrate));
;;;114    	}
;;;115    
;;;116    //	baud_h = (char)((30000000U/16U/baudrate)>>8);
;;;117    //	baud_l = (char)((30000000U/16U/baudrate));
;;;118    
;;;119    sc16is700_wr_byte(CS16IS7xx_LCR, 0x80);
00018c  2180              MOVS     r1,#0x80
00018e  2003              MOVS     r0,#3
000190  f7fffffe          BL       sc16is700_wr_byte
;;;120    sc16is700_wr_byte(CS16IS7xx_DLL, baud_l);
000194  4629              MOV      r1,r5
000196  2000              MOVS     r0,#0
000198  f7fffffe          BL       sc16is700_wr_byte
;;;121    sc16is700_wr_byte(CS16IS7xx_DLH, baud_h);
00019c  4621              MOV      r1,r4
00019e  2001              MOVS     r0,#1
0001a0  f7fffffe          BL       sc16is700_wr_byte
;;;122    sc16is700_wr_byte(CS16IS7xx_LCR, 0xBF);
0001a4  21bf              MOVS     r1,#0xbf
0001a6  2003              MOVS     r0,#3
0001a8  f7fffffe          BL       sc16is700_wr_byte
;;;123    sc16is700_wr_byte(CS16IS7xx_EFR, 0X10);
0001ac  2110              MOVS     r1,#0x10
0001ae  2002              MOVS     r0,#2
0001b0  f7fffffe          BL       sc16is700_wr_byte
;;;124    sc16is700_wr_byte(CS16IS7xx_LCR, 0x03);
0001b4  2103              MOVS     r1,#3
0001b6  4608              MOV      r0,r1
0001b8  f7fffffe          BL       sc16is700_wr_byte
;;;125    sc16is700_wr_byte(CS16IS7xx_FCR, 0x06);
0001bc  2106              MOVS     r1,#6
0001be  2002              MOVS     r0,#2
0001c0  f7fffffe          BL       sc16is700_wr_byte
;;;126    sc16is700_wr_byte(CS16IS7xx_FCR, 0x01);
0001c4  2101              MOVS     r1,#1
0001c6  2002              MOVS     r0,#2
0001c8  f7fffffe          BL       sc16is700_wr_byte
;;;127    sc16is700_wr_byte(CS16IS7xx_EFCR, 0X30);
0001cc  e8bd4070          POP      {r4-r6,lr}
0001d0  2130              MOVS     r1,#0x30
0001d2  200f              MOVS     r0,#0xf
0001d4  e7fe              B        sc16is700_wr_byte
;;;128    //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;129    //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;130    //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;131    //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;132    //sc16is700_wr_byte(CS16IS7xx_DLH, 0x04);
;;;133    }
;;;134    
                          ENDP

                  putchar_sc16is700 PROC
;;;153    //Посылка байта через sc16is700
;;;154    void putchar_sc16is700(char out_byte)
0001d6  4a4b              LDR      r2,|L1.772|
;;;155    {
;;;156    tx_buffer_sc16is700[tx_wr_index_sc16is700]=out_byte;
0001d8  4b45              LDR      r3,|L1.752|
0001da  7891              LDRB     r1,[r2,#2]  ; tx_wr_index_sc16is700
0001dc  5458              STRB     r0,[r3,r1]
;;;157    if (++tx_wr_index_sc16is700 == TX_BUFFER_SIZE_SC16IS700) tx_wr_index_sc16is700=0;
0001de  1c49              ADDS     r1,r1,#1
0001e0  b2c8              UXTB     r0,r1
0001e2  7090              STRB     r0,[r2,#2]
0001e4  2820              CMP      r0,#0x20
0001e6  d101              BNE      |L1.492|
0001e8  2000              MOVS     r0,#0
0001ea  7090              STRB     r0,[r2,#2]
                  |L1.492|
;;;158    }
0001ec  4770              BX       lr
;;;159    
                          ENDP

                  sc16is700_out PROC
;;;160    //-----------------------------------------------
;;;161    void sc16is700_out (char num,char data0,char data1,char data2,char data3,char data4,char data5)
0001ee  b5ff              PUSH     {r0-r7,lr}
;;;162    {
0001f0  ad09              ADD      r5,sp,#0x24
0001f2  cdd0              LDM      r5!,{r4,r6,r7}
;;;163    char i,t=0;
;;;164    //char *ptr=&data1;
;;;165    char UOB0[16]; 
;;;166    UOB0[0]=data0;
0001f4  f88d1000          STRB     r1,[sp,#0]
;;;167    UOB0[1]=data1;
0001f8  f88d2001          STRB     r2,[sp,#1]
;;;168    UOB0[2]=data2;
0001fc  f88d3002          STRB     r3,[sp,#2]
000200  2500              MOVS     r5,#0                 ;163
;;;169    UOB0[3]=data3;
000202  f88d4003          STRB     r4,[sp,#3]
;;;170    UOB0[4]=data4;
000206  f88d6004          STRB     r6,[sp,#4]
;;;171    UOB0[5]=data5;
00020a  f88d7005          STRB     r7,[sp,#5]
;;;172    
;;;173    for (i=0;i<num;i++)
00020e  4629              MOV      r1,r5
000210  466c              MOV      r4,sp                 ;165
000212  e003              B        |L1.540|
                  |L1.532|
;;;174    	{
;;;175    	t^=UOB0[i];
000214  5c62              LDRB     r2,[r4,r1]
000216  4055              EORS     r5,r5,r2
000218  1c49              ADDS     r1,r1,#1              ;173
00021a  b2c9              UXTB     r1,r1                 ;173
                  |L1.540|
00021c  4281              CMP      r1,r0                 ;173
00021e  d3f9              BCC      |L1.532|
;;;176    	}    
;;;177    UOB0[num]=num;
;;;178    t^=UOB0[num];
000220  ea800105          EOR      r1,r0,r5
;;;179    UOB0[num+1]=t;
000224  1822              ADDS     r2,r4,r0
000226  5420              STRB     r0,[r4,r0]            ;177
000228  7051              STRB     r1,[r2,#1]
;;;180    UOB0[num+2]=END;
00022a  210a              MOVS     r1,#0xa
;;;181    
;;;182    for (i=0;i<num+3;i++)
00022c  2500              MOVS     r5,#0
00022e  7091              STRB     r1,[r2,#2]            ;180
000230  1cc6              ADDS     r6,r0,#3
000232  e004              B        |L1.574|
                  |L1.564|
;;;183    	{
;;;184    	putchar_sc16is700(UOB0[i]);
000234  5d60              LDRB     r0,[r4,r5]
000236  f7fffffe          BL       putchar_sc16is700
00023a  1c6d              ADDS     r5,r5,#1              ;182
00023c  b2ed              UXTB     r5,r5                 ;182
                  |L1.574|
00023e  42b5              CMP      r5,r6                 ;182
000240  d3f8              BCC      |L1.564|
;;;185    	}   	
;;;186    }
000242  bdff              POP      {r0-r7,pc}
;;;187    
                          ENDP

                  sc16is700_uart_hndl PROC
;;;190    //Обработчик sc16is700
;;;191    void sc16is700_uart_hndl(void)
000244  e92d47f0          PUSH     {r4-r10,lr}
;;;192    {
;;;193    
;;;194    sc16is700ByteAvailable=sc16is700_rd_byte(CS16IS7xx_RXLVL); //Читаем состояние ФИФО приема микросхемы
000248  2009              MOVS     r0,#9
00024a  f7fffffe          BL       sc16is700_rd_byte
00024e  4c2d              LDR      r4,|L1.772|
000250  2600              MOVS     r6,#0
000252  7020              STRB     r0,[r4,#0]
;;;195    
;;;196    if(sc16is700ByteAvailable) //Если в приемном ФИФО	микросхемы есть данные
000254  b1a0              CBZ      r0,|L1.640|
;;;197    	{
;;;198    	char i;
;;;199    	for(i=0;(i<sc16is700ByteAvailable)&&(i<5);i++) //Читаем их пачками не больше 5 в программный буфер модбас
000256  2500              MOVS     r5,#0
;;;200    		{
;;;201    		if(!sc16is700RecieveDisableFlag)
;;;202    			{
;;;203    			modbus_rx_buffer[modbus_rx_buffer_ptr]=sc16is700_rd_byte(CS16IS7xx_RHR);
000258  f8df80ac          LDR      r8,|L1.776|
00025c  4f2b              LDR      r7,|L1.780|
;;;204    			modbus_rx_buffer_ptr++;
;;;205    			modbus_timeout_cnt=0;   //Запускаем таймер опознавания конца посылки 
00025e  f8df90b0          LDR      r9,|L1.784|
000262  e008              B        |L1.630|
                  |L1.612|
000264  79a0              LDRB     r0,[r4,#6]            ;201  ; sc16is700RecieveDisableFlag
000266  2800              CMP      r0,#0                 ;201
;;;206    			}
;;;207    		else sc16is700_rd_byte(CS16IS7xx_RHR);
000268  f04f0000          MOV      r0,#0
00026c  d011              BEQ      |L1.658|
00026e  f7fffffe          BL       sc16is700_rd_byte
                  |L1.626|
000272  1c6d              ADDS     r5,r5,#1              ;199
000274  b2ed              UXTB     r5,r5                 ;199
                  |L1.630|
000276  7820              LDRB     r0,[r4,#0]            ;199  ; sc16is700ByteAvailable
000278  4285              CMP      r5,r0                 ;199
00027a  d201              BCS      |L1.640|
00027c  2d05              CMP      r5,#5                 ;199
00027e  d3f1              BCC      |L1.612|
                  |L1.640|
;;;208    		}
;;;209    	}
;;;210    
;;;211    
;;;212    
;;;213    sc16is700TxFifoLevel=sc16is700_rd_byte(CS16IS7xx_TXLVL);//Читаем состояние ФИФО передачи
000280  2008              MOVS     r0,#8
000282  f7fffffe          BL       sc16is700_rd_byte
;;;214    
;;;215    if(sc16is700TxFifoLevel!=64) sc16is700TxFifoEmptyCnt=0;//Если ФИФО не пустой обнуляем счетчик свободности ФИФО передачи
;;;216    if(sc16is700TxFifoLevel==64) //если ФИФО пустой то плюсуем счетчик если он меньше константы
;;;217    	{
;;;218    	if(sc16is700TxFifoEmptyCnt<SC16IS700TXFIFOEMPTYCNTMAX)sc16is700TxFifoEmptyCnt++;
;;;219    	}
;;;220    if(sc16is700TxFifoEmptyCnt==SC16IS700TXFIFOEMPTYCNTMAX) sc16is700TxPossibleFlag=1;//Если счетчик сравнялся с константой поднимаем флаг возможности передачи
000286  2201              MOVS     r2,#1
000288  7060              STRB     r0,[r4,#1]            ;213
00028a  2840              CMP      r0,#0x40              ;215
00028c  d00b              BEQ      |L1.678|
00028e  7126              STRB     r6,[r4,#4]            ;215
000290  e011              B        |L1.694|
                  |L1.658|
000292  f7fffffe          BL       sc16is700_rd_byte
000296  7839              LDRB     r1,[r7,#0]            ;203  ; modbus_rx_buffer_ptr
000298  f8080001          STRB     r0,[r8,r1]            ;203
00029c  1c49              ADDS     r1,r1,#1              ;204
00029e  7039              STRB     r1,[r7,#0]            ;204
0002a0  f8896000          STRB     r6,[r9,#0]            ;205
0002a4  e7e5              B        |L1.626|
                  |L1.678|
0002a6  7920              LDRB     r0,[r4,#4]            ;218  ; sc16is700TxFifoEmptyCnt
0002a8  2805              CMP      r0,#5                 ;218
0002aa  d201              BCS      |L1.688|
0002ac  1c40              ADDS     r0,r0,#1              ;218
0002ae  7120              STRB     r0,[r4,#4]            ;218
                  |L1.688|
0002b0  b2c0              UXTB     r0,r0
0002b2  2805              CMP      r0,#5
0002b4  d014              BEQ      |L1.736|
                  |L1.694|
;;;221    else sc16is700TxPossibleFlag=0;//Если не сравнялся - флаг сбрасываем.
0002b6  7166              STRB     r6,[r4,#5]
                  |L1.696|
;;;222    
;;;223    
;;;224    if((tx_wr_index_sc16is700)&&(tx_wr_index_sc16is700!=tx_rd_index_sc16is700)) //Если программный буфер передачи не пуст
0002b8  78a1              LDRB     r1,[r4,#2]  ; tx_wr_index_sc16is700
0002ba  b149              CBZ      r1,|L1.720|
0002bc  78e0              LDRB     r0,[r4,#3]  ; tx_rd_index_sc16is700
0002be  4281              CMP      r1,r0
0002c0  d006              BEQ      |L1.720|
;;;225    	{
;;;226    	if(sc16is700TxPossibleFlag)//проверяем возможность передачи
0002c2  7960              LDRB     r0,[r4,#5]  ; sc16is700TxPossibleFlag
0002c4  b120              CBZ      r0,|L1.720|
;;;227    		{
;;;228    		//char i;
;;;229    		//for(;tx_rd_index_sc16is700++;tx_rd_index_sc16is700<=tx_wr_index_sc16is700)
;;;230    			//{
;;;231    		sc16is700RecieveDisableFlag=1;
0002c6  71a2              STRB     r2,[r4,#6]
;;;232    		sc16is700_wr_buff(CS16IS7xx_THR, tx_wr_index_sc16is700);
0002c8  2000              MOVS     r0,#0
0002ca  f7fffffe          BL       sc16is700_wr_buff
;;;233    			//}
;;;234    		
;;;235    		tx_wr_index_sc16is700=0;
0002ce  70a6              STRB     r6,[r4,#2]
                  |L1.720|
;;;236    		}
;;;237    	}
;;;238    
;;;239    if((sc16is700_rd_byte(CS16IS7xx_LSR))&0x40)	sc16is700RecieveDisableFlag=0;
0002d0  2005              MOVS     r0,#5
0002d2  f7fffffe          BL       sc16is700_rd_byte
0002d6  0640              LSLS     r0,r0,#25
0002d8  d500              BPL      |L1.732|
0002da  71a6              STRB     r6,[r4,#6]
                  |L1.732|
;;;240    
;;;241    
;;;242    }
0002dc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.736|
0002e0  7162              STRB     r2,[r4,#5]            ;220
0002e2  e7e9              B        |L1.696|
                          ENDP

                  |L1.740|
                          DCD      0x4002c000
                  |L1.744|
                          DCD      0x40020000
                  |L1.748|
                          DCD      0x2009c000
                  |L1.752|
                          DCD      ||.bss||
                  |L1.756|
                          DCD      0x00098968
                  |L1.760|
                          DCD      RS485_QWARZ_DIGIT
                  |L1.764|
                          DCD      0x002625a0
                  |L1.768|
                          DCD      0x001c9c38
                  |L1.772|
                          DCD      ||.data||
                  |L1.776|
                          DCD      modbus_rx_buffer
                  |L1.780|
                          DCD      modbus_rx_buffer_ptr
                  |L1.784|
                          DCD      modbus_timeout_cnt

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  tx_buffer_sc16is700
                          %        32

                          AREA ||.data||, DATA, ALIGN=0

                  sc16is700ByteAvailable
000000  00                DCB      0x00
                  sc16is700TxFifoLevel
000001  00                DCB      0x00
                  tx_wr_index_sc16is700
000002  00                DCB      0x00
                  tx_rd_index_sc16is700
000003  00                DCB      0x00
                  sc16is700TxFifoEmptyCnt
000004  00                DCB      0x00
                  sc16is700TxPossibleFlag
000005  00                DCB      0x00
                  sc16is700RecieveDisableFlag
000006  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "sc16is7xx.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_sc16is7xx_c_c1eea82f____REV16|
#line 112 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_sc16is7xx_c_c1eea82f____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_sc16is7xx_c_c1eea82f____REVSH|
#line 130
|__asm___11_sc16is7xx_c_c1eea82f____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
